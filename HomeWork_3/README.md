# Software Archicteture Homeworks

## Домашнее задание к семинару 3.

## Принципы концепции S_O_L_I_D.

#### 1. Single Responsibility Principle (SRP): Каждый класс отвечает за одну задачу. 

![SRP](/src/Sourse/SOLID_SRP.png)

* На приведенной части УМЛ диаграммы очень хорошо продемонтстрирован  принцип единственной отвественности (Single Responsibility Principle). Пользователь в организации может иметь навыки, коих может быть великое множество. Чтобы не усложнять в будущем код программы, создан абстрактный класс "Пользовательские навыки", от которого наследуются классы, каждый из которых отвечает за какой то один, конкретный навык пользователя. Данных классов можно в будущем создать неограниченное количество, и все они будут наследоваться от одного суперкласса. Весь остальной клиентский код не будет претерпевать никаких изменений.


#### 2. Open/Closed Principle (OCP): Расширяемые, но закрытые для модификации компоненты.

![OCP](/src/Sourse/UML_diaramma.png)

*  На приведенной диаграмме можно заметить, что все классы реализованы так, что они открыты для расширения, но закрыты для модификации. Так, например, класс User, имеет защищенное поле  String name, и публичный метод getName, позволяющий пользователю класса получить имя пользователя. Если вдруг возникнет необходимость расширить функционал данного класса, добавив пользователю какие то другие поля, допустим фамилию, или что то еще, это всегда можно будет сделать. При этом уже существующая часть кода закрыта модификатором  доступа private или protected.
По такому же принципу реализованы и остальные классы программы.





```В данной небольшой учебной программе трудно выделить на диаграмме все пять принципов SOLID, впрочем это и не обязательно делать. Не все из них обязательно должны присутствовать повсеместно. Данная учебная программа слишком проста, и усложнять ее, чтобы продемонстрировать остальные принципы не имеет смысла. Но ниже приложу короткое описание остальных принципов.``` 




#### Liskov Substitution Principle (LSP): Обеспечить заменяемость объектов базового класса объектами производных классов без нарушения корректности программы.

*  Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP): Объекты в программе могут быть заменены их наследниками без изменения желаемых свойств программы. Это означает, что дочерний класс должен быть полностью совместим с родительским классом.


#### Принцип разделения интерфейсов (Interface Segregation Principle, ISP):

* Клиенты не должны зависеть от интерфейсов, которыми не пользуются. Вместо этого следует создавать маленькие, специфичные интерфейсы, чтобы избежать накопления ненужных зависимостей.


#### Принцип инверсии зависимостей (Dependency Inversion Principle, DIP): 

* Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Это означает, что высокоуровневые компоненты должны зависеть от абстракций, а не от конкретных реализаций.

